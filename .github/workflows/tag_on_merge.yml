name: Tag on merge

on:
  pull_request:
    types: [closed]

jobs:
  create_tag_and_draft_release:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main'
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
      labels: ${{ steps.get_labels.outputs.labels }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR labels
        id: get_labels
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.pull_request.labels.map(label => label.name);
            core.setOutput('labels', JSON.stringify(labels));
            return labels;

      - name: Create Tag
        id: create_tag
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const labels = ${{ steps.get_labels.outputs.result }};
            const tags = (await github.rest.repos.listTags({ owner, repo, per_page: 100 })).data.map(tag => tag.name);

            function compareTags(a, b) {
              const parseTag = tag => tag.split('.').map(Number);
              const aParts = parseTag(a.split('-')[0]);
              const bParts = parseTag(b.split('-')[0]);
              for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const diff = (aParts[i] || 0) - (bParts[i] || 0);
                if (diff !== 0) return diff;
              }
              return (parseInt(a.split('-')[1] || '0')) - (parseInt(b.split('-')[1] || '0'));
            }

            tags.sort(compareTags);
            const lastTag = tags.pop();
            const parts = lastTag.split('-')[0].split('.').map(Number);
            const lastTagNumber = parseInt(lastTag.match(/-(\d+)$/)?.[1] || '0');

            if (labels.includes('upgrade')) {
              parts[0]++;
              parts[1] = parts[2] = 0;
            } else if (labels.includes('enhancement') || labels.includes('dependencies')) {
              parts[1]++;
              parts[2] = 0;
            } else {
              parts[2]++;
            }

            const newTag = `${parts.join('.')}-${lastTagNumber + 1}`;
            core.setOutput('new_tag', newTag);

            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/tags/${newTag}`,
              sha: context.payload.pull_request.merge_commit_sha,
            });

            return newTag;

  update_release_draft:
    needs: create_tag_and_draft_release
    runs-on: ubuntu-latest
    steps:
      - uses: release-drafter/release-drafter@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  publish_release:
    needs: [create_tag_and_draft_release, update_release_draft]
    runs-on: ubuntu-latest
    steps:
      - name: Publish Release
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const newTag = '${{ needs.create_tag_and_draft_release.outputs.new_tag }}';
            const labels = JSON.parse('${{ needs.create_tag_and_draft_release.outputs.labels }}');
            
            const releases = await github.rest.repos.listReleases({ owner, repo });
            const draftRelease = releases.data.find(release => release.draft);

            if (draftRelease) {
              await github.rest.repos.updateRelease({
                owner,
                repo,
                release_id: draftRelease.id,
                tag_name: newTag,
                name: newTag.replace(/-/g, ' (') + ')',
                draft: false,
                prerelease: !labels.includes('release'),
              });
            }

  update_branch_release:
    needs: publish_release
    if: contains(github.event.pull_request.labels.*.name, 'release')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: 'refs/heads/main'

      - name: Create and push branch
        run: |
          git checkout -b latest-release || git checkout latest-release
          git reset --hard origin/main
          git push --force origin latest-release

  sync_labels:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main'
    steps:
      - uses: actions/checkout@v4
      - uses: micnncim/action-label-syncer@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          manifest: .github/labels.yml
          prune: true